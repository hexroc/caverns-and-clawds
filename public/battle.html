<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C&C Battle Arena</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 100%);
            font-family: 'Courier New', monospace;
        }
        canvas { display: block; }
        
        /* Login overlay */
        #login-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #login-box {
            background: #1a1a2e;
            border: 2px solid #4a9eff;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            color: #fff;
        }
        #login-box h2 { color: #4a9eff; margin-bottom: 20px; }
        #login-box input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: #0a0a1a;
            border: 1px solid #333;
            color: #fff;
            border-radius: 6px;
            font-family: monospace;
        }
        #login-box button {
            width: 100%;
            padding: 12px;
            margin-top: 15px;
            background: linear-gradient(135deg, #4a9eff, #00d4ff);
            border: none;
            color: #000;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
        }
        #login-box button:hover { opacity: 0.9; }
        #login-error { color: #f87171; margin-top: 10px; display: none; }
        
        /* UI panels */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4a9eff;
            min-width: 220px;
            max-height: 45vh;
            overflow-y: auto;
        }
        #ui h2 { 
            color: #4a9eff; 
            margin-bottom: 10px;
            font-size: 18px;
        }
        .combatant {
            margin: 8px 0;
            padding: 10px;
            background: rgba(255,255,255,0.08);
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .combatant:hover { background: rgba(255,255,255,0.15); }
        .combatant.friendly { border-left: 3px solid #4ade80; }
        .combatant.enemy { border-left: 3px solid #f87171; }
        .combatant.selected { background: rgba(74, 158, 255, 0.3); }
        .combatant.dead { opacity: 0.4; }
        .hp-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin-top: 6px;
            overflow: hidden;
        }
        .hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            transition: width 0.3s;
        }
        .hp-fill.low { background: linear-gradient(90deg, #ef4444, #f87171); }
        .hp-fill.medium { background: linear-gradient(90deg, #f59e0b, #fbbf24); }
        
        /* Action buttons */
        #actions {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4a9eff;
        }
        #actions h3 { color: #4a9eff; margin-bottom: 10px; font-size: 14px; }
        .action-btn {
            display: block;
            width: 100%;
            padding: 10px 15px;
            margin: 6px 0;
            background: linear-gradient(135deg, #333, #222);
            border: 1px solid #555;
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            text-align: left;
            transition: all 0.2s;
        }
        .action-btn:hover:not(:disabled) { 
            background: linear-gradient(135deg, #444, #333);
            border-color: #4a9eff;
        }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .action-btn.attack { border-left: 3px solid #f87171; }
        .action-btn.spell { border-left: 3px solid #a78bfa; }
        .action-btn.heal { border-left: 3px solid #4ade80; }
        .action-btn.flee { border-left: 3px solid #fbbf24; }
        
        /* Spell list */
        #spell-list {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }
        #spell-list.visible { display: block; }
        .spell-btn {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin: 4px 0;
            background: #1a1a2e;
            border: 1px solid #a78bfa;
            color: #a78bfa;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
            text-align: left;
        }
        .spell-btn:hover { background: #2a2a4e; }
        
        /* Combat log */
        #combat-log {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            max-height: 180px;
            overflow-y: auto;
            background: rgba(0,0,0,0.9);
            color: #ccc;
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            border: 1px solid #333;
        }
        .log-entry { margin: 4px 0; line-height: 1.4; }
        .log-entry.damage { color: #f87171; }
        .log-entry.heal { color: #4ade80; }
        .log-entry.action { color: #60a5fa; }
        .log-entry.system { color: #888; font-style: italic; }
        .log-entry.miss { color: #fbbf24; }
        .log-entry.crit { color: #ff6b6b; font-weight: bold; }
        
        /* Status bar */
        #status-bar {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #4a9eff;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 18px;
            display: none;
            border: 2px solid #4a9eff;
        }
        
        /* No combat message */
        #no-combat {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 500;
        }
        #no-combat-box {
            background: #1a1a2e;
            border: 2px solid #fbbf24;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            color: #fff;
        }
        #no-combat-box h2 { color: #fbbf24; margin-bottom: 15px; }
        #no-combat-box button {
            padding: 12px 30px;
            margin-top: 15px;
            background: #fbbf24;
            border: none;
            color: #000;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
        }
        
        /* Controls hint */
        #controls {
            position: absolute;
            bottom: 200px;
            right: 10px;
            color: #666;
            font-size: 11px;
            text-align: right;
        }
    </style>
</head>
<body>
    <!-- Login overlay -->
    <div id="login-overlay">
        <div id="login-box">
            <h2>ü¶û C&C Battle Arena</h2>
            <p style="color: #888; margin-bottom: 15px;">Enter your API key to join combat</p>
            <input type="text" id="api-key-input" placeholder="dnd_xxxxxxxx..." />
            <button onclick="login()">Enter Battle</button>
            <div id="login-error"></div>
        </div>
    </div>
    
    <!-- No combat overlay -->
    <div id="no-combat">
        <div id="no-combat-box">
            <h2>‚öîÔ∏è No Active Combat</h2>
            <p>You're not currently in a fight.</p>
            <p style="color: #888; margin-top: 10px;">Go explore a zone to find monsters!</p>
            <button onclick="checkCombat()">Refresh</button>
        </div>
    </div>

    <!-- Combat UI -->
    <div id="ui" style="display: none;">
        <h2>‚öîÔ∏è COMBAT</h2>
        <div id="round-info" style="color: #888; font-size: 12px; margin-bottom: 10px;">Round 1</div>
        <div id="combatants"></div>
    </div>
    
    <div id="actions" style="display: none;">
        <h3>‚ö° ACTIONS</h3>
        <div id="turn-indicator" style="margin-bottom: 10px; padding: 8px; background: #1a3a1a; border-radius: 4px; display: none;">
            <span style="color: #4ade80;">YOUR TURN</span>
        </div>
        <button class="action-btn attack" onclick="doAttack()">‚öîÔ∏è Attack</button>
        <button class="action-btn spell" onclick="toggleSpells()">‚ú® Cast Spell</button>
        <div id="spell-list"></div>
        <button class="action-btn flee" onclick="doFlee()">üèÉ Flee</button>
        <div id="spell-slots" style="margin-top: 15px; font-size: 11px; color: #888;"></div>
    </div>
    
    <div id="combat-log">
        <div class="log-entry system">Connecting to battle...</div>
    </div>
    
    <div id="status-bar"></div>
    
    <div id="controls">
        üñ±Ô∏è Drag to rotate | Scroll to zoom<br>
        Click enemy to target
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ===== CONFIG =====
        const API_BASE = window.location.origin;
        let apiKey = localStorage.getItem('cnc_api_key') || '';
        let combatState = null;
        let selectedTarget = null;
        let combatants3D = {};
        let pollInterval = null;
        
        // ===== THREE.JS SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a1a);
        
        const aspect = window.innerWidth / window.innerHeight;
        const d = 12;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(15, 15, 15);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.insertBefore(renderer.domElement, document.body.firstChild);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minPolarAngle = Math.PI / 6;
        
        // Lighting
        scene.add(new THREE.AmbientLight(0x404060, 0.5));
        const sun = new THREE.DirectionalLight(0xffffff, 0.7);
        sun.position.set(10, 20, 10);
        sun.castShadow = true;
        scene.add(sun);
        
        // Underwater caustic effect
        const caustic = new THREE.PointLight(0x00ffff, 0.4, 25);
        caustic.position.set(0, 8, 0);
        scene.add(caustic);
        
        // ===== MATERIALS =====
        const mats = {
            sand: new THREE.MeshLambertMaterial({ color: 0xc2b280 }),
            sandDark: new THREE.MeshLambertMaterial({ color: 0xa89860 }),
            rock: new THREE.MeshLambertMaterial({ color: 0x5a5a5a }),
            coral: new THREE.MeshLambertMaterial({ color: 0xff6b6b }),
            seaweed: new THREE.MeshLambertMaterial({ color: 0x228b22 }),
            lobsterRed: new THREE.MeshLambertMaterial({ color: 0xdc143c }),
            lobsterGhost: new THREE.MeshLambertMaterial({ color: 0x88ccff, transparent: true, opacity: 0.7 }),
            shark: new THREE.MeshLambertMaterial({ color: 0x708090 }),
            octopus: new THREE.MeshLambertMaterial({ color: 0x8b008b }),
            crab: new THREE.MeshLambertMaterial({ color: 0xff4500 }),
            eel: new THREE.MeshLambertMaterial({ color: 0x2f4f4f }),
            eye: new THREE.MeshLambertMaterial({ color: 0x000000 }),
            eyeWhite: new THREE.MeshLambertMaterial({ color: 0xffffff }),
            highlight: new THREE.MeshBasicMaterial({ color: 0x4a9eff, transparent: true, opacity: 0.3 }),
            targetHighlight: new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.4 }),
        };
        
        // ===== BUILD ARENA =====
        function buildArena() {
            const gridSize = 8;
            for (let x = -gridSize/2; x < gridSize/2; x++) {
                for (let z = -gridSize/2; z < gridSize/2; z++) {
                    const h = Math.random() * 0.2;
                    const geo = new THREE.BoxGeometry(1.95, 0.4 + h, 1.95);
                    const tile = new THREE.Mesh(geo, Math.random() > 0.3 ? mats.sand : mats.sandDark);
                    tile.position.set(x * 2, -0.2 - h/2, z * 2);
                    tile.receiveShadow = true;
                    scene.add(tile);
                }
            }
            
            // Decorations
            addRock(-6, -6, 1.2);
            addRock(5, -4, 0.8);
            addCoral(-5, 4);
            addCoral(4, 5);
            addSeaweed(6, 2);
            addSeaweed(-6, -2);
        }
        
        function addRock(x, z, s = 1) {
            const geo = new THREE.DodecahedronGeometry(0.4 * s);
            const rock = new THREE.Mesh(geo, mats.rock);
            rock.position.set(x, 0.2 * s, z);
            rock.rotation.set(Math.random(), Math.random(), 0);
            rock.castShadow = true;
            scene.add(rock);
        }
        
        function addCoral(x, z) {
            const g = new THREE.Group();
            for (let i = 0; i < 4; i++) {
                const h = 0.4 + Math.random() * 0.8;
                const geo = new THREE.CylinderGeometry(0.04, 0.12, h, 5);
                const branch = new THREE.Mesh(geo, mats.coral);
                branch.position.set((Math.random()-0.5)*0.4, h/2, (Math.random()-0.5)*0.4);
                branch.rotation.set((Math.random()-0.5)*0.3, 0, (Math.random()-0.5)*0.3);
                g.add(branch);
            }
            g.position.set(x, 0, z);
            scene.add(g);
        }
        
        function addSeaweed(x, z) {
            const g = new THREE.Group();
            for (let i = 0; i < 3; i++) {
                const h = 0.8 + Math.random() * 1.2;
                const geo = new THREE.CylinderGeometry(0.02, 0.04, h, 4);
                const strand = new THREE.Mesh(geo, mats.seaweed);
                strand.position.set((Math.random()-0.5)*0.2, h/2, (Math.random()-0.5)*0.2);
                strand.rotation.z = (Math.random()-0.5)*0.3;
                g.add(strand);
            }
            g.position.set(x, 0, z);
            scene.add(g);
        }
        
        // ===== CREATE COMBATANT MODELS =====
        function createLobster(color = mats.lobsterRed) {
            const g = new THREE.Group();
            
            // Body
            const bodyGeo = new THREE.SphereGeometry(0.4, 8, 6);
            bodyGeo.scale(1, 0.6, 1.3);
            const body = new THREE.Mesh(bodyGeo, color);
            body.position.y = 0.4;
            body.castShadow = true;
            g.add(body);
            
            // Head
            const headGeo = new THREE.SphereGeometry(0.25, 8, 6);
            const head = new THREE.Mesh(headGeo, color);
            head.position.set(0, 0.5, 0.5);
            g.add(head);
            
            // Eyes
            for (let s of [-1, 1]) {
                const stalk = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.15, 4), color);
                stalk.position.set(s * 0.12, 0.7, 0.55);
                stalk.rotation.x = -0.3;
                g.add(stalk);
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), mats.eyeWhite);
                eye.position.set(s * 0.12, 0.78, 0.6);
                g.add(eye);
            }
            
            // Claws
            for (let s of [-1, 1]) {
                const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.05, 0.5, 6), color);
                arm.position.set(s * 0.4, 0.3, 0.2);
                arm.rotation.z = s * 0.5;
                g.add(arm);
                const clawGeo = new THREE.SphereGeometry(0.15, 6, 6);
                clawGeo.scale(1.1, 0.5, 0.7);
                const claw = new THREE.Mesh(clawGeo, color);
                claw.position.set(s * 0.65, 0.4, 0.4);
                g.add(claw);
            }
            
            // Tail
            for (let i = 0; i < 4; i++) {
                const seg = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2 - i*0.03, 6, 6),
                    color
                );
                seg.scale.y = 0.5;
                seg.position.set(0, 0.3 - i*0.04, -0.4 - i*0.25);
                g.add(seg);
            }
            
            return g;
        }
        
        function createShark() {
            const g = new THREE.Group();
            const bodyGeo = new THREE.ConeGeometry(0.4, 1.8, 8);
            bodyGeo.rotateX(Math.PI / 2);
            const body = new THREE.Mesh(bodyGeo, mats.shark);
            body.position.y = 0.6;
            body.castShadow = true;
            g.add(body);
            
            const finGeo = new THREE.ConeGeometry(0.15, 0.5, 4);
            const fin = new THREE.Mesh(finGeo, mats.shark);
            fin.position.set(0, 1.1, -0.2);
            fin.rotation.x = -0.2;
            g.add(fin);
            
            for (let s of [-1, 1]) {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6), mats.eye);
                eye.position.set(s * 0.28, 0.65, 0.5);
                g.add(eye);
            }
            
            return g;
        }
        
        function createOctopus() {
            const g = new THREE.Group();
            const headGeo = new THREE.SphereGeometry(0.5, 8, 8);
            headGeo.scale(1, 1.1, 1);
            const head = new THREE.Mesh(headGeo, mats.octopus);
            head.position.y = 1;
            head.castShadow = true;
            g.add(head);
            
            for (let s of [-1, 1]) {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), mats.eyeWhite);
                eye.position.set(s * 0.25, 1.05, 0.38);
                g.add(eye);
                const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6), mats.eye);
                pupil.position.set(s * 0.25, 1.05, 0.48);
                g.add(pupil);
            }
            
            // Tentacles
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                for (let j = 0; j < 5; j++) {
                    const size = 0.1 - j * 0.012;
                    const seg = new THREE.Mesh(new THREE.SphereGeometry(size, 6, 6), mats.octopus);
                    seg.scale.y = 0.6;
                    const dist = 0.35 + j * 0.22;
                    seg.position.set(Math.sin(angle) * dist, 0.25 - j * 0.04, Math.cos(angle) * dist);
                    g.add(seg);
                }
            }
            
            return g;
        }
        
        function createGenericMonster() {
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), mats.eel);
            body.position.y = 0.5;
            body.castShadow = true;
            g.add(body);
            for (let s of [-1, 1]) {
                const eye = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), mats.eyeWhite);
                eye.position.set(s * 0.2, 0.6, 0.35);
                g.add(eye);
            }
            return g;
        }
        
        function getModelForMonster(name) {
            const n = name.toLowerCase();
            if (n.includes('shark')) return createShark();
            if (n.includes('octopus')) return createOctopus();
            if (n.includes('lobster')) return createLobster();
            return createGenericMonster();
        }
        
        // ===== FLOATING DAMAGE =====
        const floatingDamage = [];
        
        function spawnDamage(x, y, z, text, isHeal = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = isHeal ? '#4ade80' : '#f87171';
            ctx.textAlign = 'center';
            ctx.fillText(text, 64, 45);
            
            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.position.set(x, y, z);
            sprite.scale.set(1.5, 0.75, 1);
            scene.add(sprite);
            
            floatingDamage.push({ sprite, life: 50, velocity: 0.025 });
        }
        
        // ===== API FUNCTIONS =====
        async function apiCall(endpoint, method = 'GET', body = null) {
            const opts = {
                method,
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json'
                }
            };
            if (body) opts.body = JSON.stringify(body);
            
            const res = await fetch(`${API_BASE}${endpoint}`, opts);
            return res.json();
        }
        
        async function login() {
            const input = document.getElementById('api-key-input');
            const key = input.value.trim();
            if (!key) {
                showLoginError('Please enter your API key');
                return;
            }
            
            apiKey = key;
            
            // Test the key
            const status = await apiCall('/api/zone/status');
            if (!status.success) {
                showLoginError(status.error || 'Invalid API key');
                return;
            }
            
            localStorage.setItem('cnc_api_key', key);
            document.getElementById('login-overlay').style.display = 'none';
            
            // Check for combat
            checkCombat();
        }
        
        function showLoginError(msg) {
            const el = document.getElementById('login-error');
            el.textContent = msg;
            el.style.display = 'block';
        }
        
        async function checkCombat() {
            const data = await apiCall('/api/zone/combat');
            
            if (!data.inCombat) {
                document.getElementById('no-combat').style.display = 'flex';
                document.getElementById('ui').style.display = 'none';
                document.getElementById('actions').style.display = 'none';
                if (pollInterval) clearInterval(pollInterval);
                return;
            }
            
            document.getElementById('no-combat').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('actions').style.display = 'block';
            
            updateCombatState(data);
            
            // Start polling
            if (!pollInterval) {
                pollInterval = setInterval(pollCombat, 2000);
            }
        }
        
        async function pollCombat() {
            const data = await apiCall('/api/zone/combat');
            if (!data.inCombat) {
                document.getElementById('no-combat').style.display = 'flex';
                clearInterval(pollInterval);
                pollInterval = null;
                return;
            }
            updateCombatState(data);
        }
        
        function updateCombatState(data) {
            combatState = data;
            
            // Update round info
            document.getElementById('round-info').textContent = 
                `Round ${data.encounter.round} | Turn: ${data.encounter.currentTurn}`;
            
            // Update turn indicator
            const turnEl = document.getElementById('turn-indicator');
            if (data.encounter.isYourTurn) {
                turnEl.style.display = 'block';
            } else {
                turnEl.style.display = 'none';
            }
            
            // Build combatant list
            const container = document.getElementById('combatants');
            container.innerHTML = '';
            
            // Player
            const char = data.character;
            const playerDiv = createCombatantDiv('player', char.name, char.hp, char.maxHp, true);
            container.appendChild(playerDiv);
            
            // Monsters
            data.monsters.forEach((m, i) => {
                const div = createCombatantDiv(m.id, m.name, m.hp, m.maxHp, false);
                div.onclick = () => selectTarget(m.id, m.name);
                container.appendChild(div);
            });
            
            // Update 3D scene
            update3DScene(data);
        }
        
        function createCombatantDiv(id, name, hp, maxHp, friendly) {
            const div = document.createElement('div');
            div.className = `combatant ${friendly ? 'friendly' : 'enemy'}`;
            div.dataset.id = id;
            
            if (hp <= 0) div.classList.add('dead');
            if (id === selectedTarget) div.classList.add('selected');
            
            const pct = Math.max(0, (hp / maxHp) * 100);
            const hpClass = pct < 25 ? 'low' : pct < 50 ? 'medium' : '';
            
            div.innerHTML = `
                <div>${friendly ? 'ü¶û' : 'üëπ'} <strong>${name}</strong></div>
                <div class="hp-bar"><div class="hp-fill ${hpClass}" style="width: ${pct}%"></div></div>
                <small>HP: ${hp}/${maxHp}</small>
            `;
            
            return div;
        }
        
        function selectTarget(id, name) {
            selectedTarget = id;
            addLog(`üéØ Targeting ${name}`, 'action');
            
            // Update UI
            document.querySelectorAll('.combatant').forEach(el => {
                el.classList.toggle('selected', el.dataset.id === id);
            });
            
            // Update 3D highlights
            update3DHighlights();
        }
        
        function update3DScene(data) {
            // Clear old combatants
            Object.values(combatants3D).forEach(obj => scene.remove(obj.group));
            combatants3D = {};
            
            // Add player
            const playerModel = createLobster(mats.lobsterRed);
            playerModel.position.set(-3, 0, 0);
            scene.add(playerModel);
            combatants3D['player'] = { group: playerModel, x: -3, z: 0 };
            
            // Add monsters in a semicircle
            const monsters = data.monsters;
            monsters.forEach((m, i) => {
                const angle = (Math.PI / (monsters.length + 1)) * (i + 1) - Math.PI / 2;
                const x = Math.cos(angle) * 4 + 2;
                const z = Math.sin(angle) * 4;
                
                const model = getModelForMonster(m.name);
                model.position.set(x, 0, z);
                model.lookAt(-3, 0, 0); // Face player
                scene.add(model);
                combatants3D[m.id] = { group: model, x, z };
            });
            
            update3DHighlights();
        }
        
        function update3DHighlights() {
            // Remove old highlights
            scene.children
                .filter(c => c.userData.isHighlight)
                .forEach(c => scene.remove(c));
            
            // Add target highlight
            if (selectedTarget && combatants3D[selectedTarget]) {
                const { x, z } = combatants3D[selectedTarget];
                const geo = new THREE.PlaneGeometry(1.6, 1.6);
                const highlight = new THREE.Mesh(geo, mats.targetHighlight);
                highlight.rotation.x = -Math.PI / 2;
                highlight.position.set(x, 0.02, z);
                highlight.userData.isHighlight = true;
                scene.add(highlight);
            }
        }
        
        // ===== COMBAT ACTIONS =====
        async function doAttack() {
            if (!combatState?.encounter?.isYourTurn) {
                addLog('‚è≥ Wait for your turn!', 'system');
                return;
            }
            
            const target = selectedTarget || combatState.monsters[0]?.id;
            addLog(`‚öîÔ∏è Attacking...`, 'action');
            
            const result = await apiCall('/api/zone/combat/action', 'POST', { 
                action: 'attack', 
                target 
            });
            
            handleCombatResult(result);
        }
        
        function toggleSpells() {
            const list = document.getElementById('spell-list');
            list.classList.toggle('visible');
            
            if (list.classList.contains('visible') && list.children.length === 0) {
                // TODO: Fetch actual spells from character
                const spells = ['Sacred Flame', 'Guiding Bolt', 'Cure Wounds', 'Fire Bolt'];
                spells.forEach(name => {
                    const btn = document.createElement('button');
                    btn.className = 'spell-btn';
                    btn.textContent = name;
                    btn.onclick = () => castSpell(name.toLowerCase().replace(/ /g, '_'));
                    list.appendChild(btn);
                });
            }
        }
        
        async function castSpell(spellId) {
            if (!combatState?.encounter?.isYourTurn) {
                addLog('‚è≥ Wait for your turn!', 'system');
                return;
            }
            
            const target = selectedTarget || combatState.monsters[0]?.id;
            addLog(`‚ú® Casting spell...`, 'action');
            
            const result = await apiCall('/api/zone/combat/action', 'POST', { 
                action: 'spell',
                spellId,
                target 
            });
            
            handleCombatResult(result);
            document.getElementById('spell-list').classList.remove('visible');
        }
        
        async function doFlee() {
            addLog(`üèÉ Attempting to flee...`, 'action');
            
            const result = await apiCall('/api/zone/combat/flee', 'POST');
            
            if (result.success && result.escaped) {
                addLog(`üèÉ You escaped!`, 'system');
                setTimeout(checkCombat, 1000);
            } else {
                addLog(`‚ùå Couldn't escape!`, 'damage');
            }
        }
        
        function handleCombatResult(result) {
            if (!result.success) {
                addLog(`‚ùå ${result.error}`, 'system');
                return;
            }
            
            // Parse the narrative
            const msg = result.message || result.narrative || '';
            
            // Check for damage dealt
            const dmgMatch = msg.match(/(\d+)\s*(damage|points)/i);
            if (dmgMatch && selectedTarget && combatants3D[selectedTarget]) {
                const { x, z } = combatants3D[selectedTarget];
                spawnDamage(x, 1.5, z, `-${dmgMatch[1]}`);
            }
            
            // Check for healing
            const healMatch = msg.match(/heal.*?(\d+)|(\d+)\s*hp.*?restored/i);
            if (healMatch) {
                const amt = healMatch[1] || healMatch[2];
                const pos = combatants3D['player'];
                if (pos) spawnDamage(pos.x, 1.5, pos.z, `+${amt}`, true);
            }
            
            // Add to log
            if (msg.includes('critical') || msg.includes('Critical')) {
                addLog(`üí• ${msg}`, 'crit');
            } else if (msg.includes('miss') || msg.includes('Miss')) {
                addLog(`üéØ ${msg}`, 'miss');
            } else if (msg.includes('damage')) {
                addLog(`‚öîÔ∏è ${msg}`, 'damage');
            } else if (msg.includes('heal')) {
                addLog(`üíö ${msg}`, 'heal');
            } else {
                addLog(msg, 'action');
            }
            
            // Check combat end
            if (result.combatEnded) {
                if (result.victory) {
                    addLog(`üéâ Victory! Gained ${result.xpGained || 0} XP`, 'heal');
                } else {
                    addLog(`üíÄ Defeated!`, 'damage');
                }
                setTimeout(checkCombat, 2000);
            } else {
                // Refresh state
                pollCombat();
            }
        }
        
        function addLog(text, type = 'action') {
            const log = document.getElementById('combat-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = text;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            
            // Keep log size reasonable
            while (log.children.length > 50) {
                log.removeChild(log.firstChild);
            }
        }
        
        // ===== ANIMATION =====
        let time = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;
            
            controls.update();
            
            // Animate caustic light
            caustic.position.x = Math.sin(time * 0.5) * 4;
            caustic.position.z = Math.cos(time * 0.3) * 4;
            caustic.intensity = 0.4 + Math.sin(time * 2) * 0.1;
            
            // Bob combatants
            Object.values(combatants3D).forEach((c, i) => {
                if (c.group) {
                    c.group.position.y = Math.sin(time * 1.5 + i) * 0.04;
                }
            });
            
            // Animate floating damage
            for (let i = floatingDamage.length - 1; i >= 0; i--) {
                const fd = floatingDamage[i];
                fd.sprite.position.y += fd.velocity;
                fd.sprite.material.opacity = fd.life / 50;
                fd.life--;
                if (fd.life <= 0) {
                    scene.remove(fd.sprite);
                    floatingDamage.splice(i, 1);
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // ===== INIT =====
        buildArena();
        animate();
        
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Auto-login if key stored
        if (apiKey) {
            document.getElementById('api-key-input').value = apiKey;
            login();
        }
    </script>
</body>
</html>
